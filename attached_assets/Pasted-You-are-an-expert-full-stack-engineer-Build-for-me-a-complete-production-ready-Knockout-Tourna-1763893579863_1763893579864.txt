You are an expert full-stack engineer.  
Build for me a **complete, production-ready Knockout Tournament Management System** using:

Backend → Python FastAPI  
Frontend → React / Next.js + Tailwind CSS  
Database → Supabase (Postgres)  
Hosting → Frontend on Vercel, Backend on Render (or any server)  
State → Fully dynamic, scalable, no mock data  
Realtime → Supabase realtime OR secure backend polling  

IMPORTANT RULES:  
✅ You MUST connect the backend and frontend to MY real Supabase project.  
→ Always ASK ME for:  
   - SUPABASE_URL  
   - SUPABASE_ANON_KEY  
   - SUPABASE_SERVICE_KEY (only when needed for backend ops)  
→ Do NOT use mock data at any point.  
→ Every fetch, insert, update, delete MUST go to my real Supabase instance.  
→ No placeholder URLs, no dummy data.  

---

# 1️⃣ SYSTEM GOAL
Build a professional, enterprise-level tournament engine that handles:

✔ Knockout fixture generation  
✔ Same-club avoidance in early rounds  
✔ Automatic bye allocation  
✔ Multi-court smart scheduling  
✔ Minimum 10-minute rest time between matches  
✔ Zero overlapping matches for any player  
✔ Umpire-specific secure match codes  
✔ Realtime results & automatic progression to next rounds  
✔ Dynamic leaderboard  
✔ Bulk CSV player registration for large events  
✔ Clean, modern, market-ready UI  
✔ Fully dynamic + scalable  
✔ All modules fully integrated with Supabase  

---

# 2️⃣ BACKEND — PYTHON FASTAPI  
Create a **production-ready backend** with full Supabase integration (no mock data).

Ask me for Supabase credentials at the beginning:
- SUPABASE_URL  
- SUPABASE_SERVICE_KEY  

Use the official Supabase Python client.

## Backend Modules & Logic (VERY IMPORTANT — FOLLOW EXACTLY)

### **A. Player + Club + CSV Registration Module**
#### Player Registration Logic:
- Accept: name, age, phone, club_id, event_ids
- Validate:  
  - No duplicate names *within same event*  
  - Valid phone  
  - Valid club  
- Generate UUID for player  
- Insert into `players` table (Supabase)

#### Club Registration Logic:
- Accept: club name  
- Prevent duplicate club names  
- Insert into `clubs`

#### CSV Bulk Registration Logic:
- Accept CSV file  
- Parse each row  
- Validate each field  
- Generate UUID for each valid row  
- Insert all valid rows in Supabase via batch insert  
- Return a JSON report: valid rows inserted, rows rejected, and reasons  

#### Backend Endpoints:
- POST /players  
- POST /players/upload-csv  
- GET /players  
- POST /clubs  
- GET /clubs  

---

### **B. Knockout Fixture Generation (NO ROUND ROBIN)**
✔ Only Knockout format  
✔ Must dynamically support 8, 16, 32, 64, 128 players  

#### Fixture Logic:
1. Fetch players for event from Supabase  
2. n = total players  
3. If n is not a power of 2 → calculate byes:  
   - byes = next_power_of_two(n) - n  
4. Distribute byes  
5. Shuffle players while minimizing same-club matchups:
   - Track clubs  
   - Avoid pairing same club in Round 1 unless unavoidable  
6. Generate matches table entries:
   - id (UUID)  
   - event_id  
   - round_number  
   - player1_id  
   - player2_id (or None for bye)  
   - status = "pending"  

#### Endpoints:
- POST /generate-fixtures  
- GET /fixtures/{event_id}  

---

### **C. Smart Multi-Court Scheduling Engine**
The most important part.

#### Scheduling Logic Rules:
- Courts = dynamic  
- A player cannot have 2 matches overlapping  
- A player MUST get at least **10 minutes rest** between matches  
- Matches on a court must have buffer time  
- Courts must not stay idle unnecessarily  
- If a match is delayed, the whole schedule should auto-adjust  

Use timeline-based scheduling:

1. Order matches by round  
2. For each match:  
   - Find earliest available court  
   - Check availability of both players  
   - Check last match end + 10 min rest  
   - Compute start and end time  
   - Update Supabase `matches` with court_id, start_time, end_time  

#### Endpoints:
- POST /schedule-matches  
- GET /schedule/{court_id}  

---

### **D. Umpire Match Code System (MANDATORY)**
#### Match Code Logic:
- When a match is created → generate unique secret code  
- Store in Supabase `match_codes`:  
  - match_id  
  - code  
  - assigned_umpire  
  - expires_at  
- Umpire must enter code to open scoring screen  
- Code must expire after match completion  
- Only correct code can modify match score  

#### Endpoints:
- POST /match-code/generate  
- POST /match-code/verify  
- POST /match/submit-score  

---

### **E. Live Results + Leaderboard**
#### Logic:
- Store score in `scores` table  
- Automatically determine winner  
- Automatically insert winner in next-round match  
- Trigger Supabase realtime event or poll updates  
- Leaderboard ranking:  
  - Wins > sets > points  

#### Endpoints:
- POST /update-score  
- GET /leaderboard/{event_id}  

---

# 3️⃣ SUPABASE SCHEMA (CREATE EXACTLY)

players:
id (UUID PK)
name (text)
age (int)
phone (text)
club_id (UUID FK -> clubs.id)
event_ids (array)

clubs:
id (UUID PK)
name (text)

events:
id (UUID PK)
name (text)
type (text = "knockout")
min_rest (int default 10)

matches:
id (UUID PK)
event_id (UUID)
round (int)
player1_id (UUID)
player2_id (UUID)
court_id (text or int)
start_time (timestamp)
end_time (timestamp)
status (text)

scores:
match_id (UUID PK)
player1_score (int)
player2_score (int)

match_codes:
match_id (UUID PK)
code (text)
assigned_umpire (text)
expires_at (timestamp)

yaml
Copy code

---

# 4️⃣ FRONTEND — NEXT.JS + TAILWIND  
Build a **beautiful, market-ready UI** with:

✔ Dashboard  
✔ Player registration form  
✔ CSV upload page  
✔ Club registration form  
✔ Fixture bracket viewer  
✔ Court scheduling viewer  
✔ Match scoring page (with match code validation)  
✔ Live leaderboard  
✔ Fully responsive  
✔ Smooth animations  
✔ Admin panel  

### Frontend Rules:
- Connect directly to FastAPI backend  
- Use SWR or React Query  
- Use Tailwind for UI  
- No mock data  
- All endpoints should use real backend URLs  
- Handle loading states, success, and error messages  

---

# 5️⃣ ABSOLUTE REQUIREMENTS FOR AI
1. ALWAYS ask me for my Supabase URL + Keys when needed.  
2. NEVER use mock data.  
3. ALWAYS connect backend → Supabase.  
4. ALWAYS connect frontend → backend.  
5. Generate code in correct structure with all files.  
6. Follow the exact logic described.  
7. Write clean, scalable, production-ready code.  
8. Ensure ALL features are implemented.  
9. UI must look professional and ready for market.  
10. Include environment variable setup for frontend and backend.  

---

# 6️⃣ EXPECTED OUTPUT
You will generate the full application:

✔ Backend code (all endpoints, logic, Supabase integration)  
✔ Frontend code (pages, components, API calls, UI)  
✔ Instructions to run both  
✔ Deployment steps  
✔ Full working dynamic system  

Begin by asking:  
**“Please provide your SUPABASE_URL, SUPABASE_ANON_KEY, and SUPABASE_SERVICE_KEY so I can connect the backend and start building.”**